#!/usr/bin/env bash

set -o errexit

# Resolve the docker tool path
DOCKER_EXE="%{docker_tool_path}"
DOCKER_FLAGS="%{docker_flags}"

if [[ -z $DOCKER_EXE ]]; then
    echo >&2 "error: docker not found; do you need to manually configure the docker toolchain?"
    exit 1
fi

DOCKER="$DOCKER_EXE $DOCKER_FLAGS"

# Redirect output to a log so we can be silent on success
LOGFILE=$(mktemp --suffix=.log)
trap exit_func EXIT
function exit_func() {
  rm -f ${LOGFILE}
}

function strjoin() {
    local delim=${1-}
    local first=${2-}
    if shift 2; then
        printf %s "${first}" "${@/#/${delim}}"
    fi
}

if ! (
    # this set of docker commands are assumed to be more-or-less atomic, but this
    # is not necessarily true in practice
    # the source docker first command is the script generated by `container_image()` that is customarily
    # executed by `bazel run`, which loads the generated docker image and all its dependent image
    # layers into the local docker client
    $DOCKER load -i %{source_image_tar}
    $DOCKER load -i %{aws_nitro_image_tar}

    $DOCKER image ls >/dev/stderr

    EIF_FILE="/tmp/enclave.eif"
    EIF_JSON="/tmp/enclave.json"

    cat >%{commands} << SCRIPT
#!/bin/bash
set -o errexit
set -o xtrace

nitro-cli build-enclave --docker-uri %{source_image_tagged} --output-file /tmp/enclave.eif > /tmp/enclave.json
SCRIPT

    # run the above "commands" script inside the aws image docker container
    container_id=$($DOCKER run -d --entrypoint=/bin/bash %{docker_run_flags} %{aws_image_tagged} -xc "
$(cat %{commands})
")
    retcode=$($DOCKER wait $container_id)
    if [[ $retcode -ne 0 ]]; then
        $DOCKER logs $container_id && false
        exit $retcode
    fi

    $DOCKER cp $container_id:${EIF_FILE} %{out_eif}
    $DOCKER cp $container_id:${EIF_JSON} %{out_eif_json}
    cat %{out_eif_json}
    $DOCKER rm $container_id
) > "$LOGFILE" 2>&1; then
    cat "$LOGFILE"
    exit 1
fi
